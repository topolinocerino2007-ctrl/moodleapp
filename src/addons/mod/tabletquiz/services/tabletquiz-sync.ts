// (C) Copyright 2015 Moodle Pty Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { Injectable } from '@angular/core';

import { CoreError } from '@classes/errors/error';
import { CoreCourseActivitySyncBaseProvider } from '@features/course/classes/activity-sync';
import { CoreCourse, CoreCourseModuleBasicInfo } from '@features/course/services/course';
import { CoreCourseLogHelper } from '@features/course/services/log-helper';
import { CoreCourseModulePrefetchDelegate } from '@features/course/services/module-prefetch-delegate';
import { CoreQuestion, CoreQuestionQuestionParsed } from '@features/question/services/question';
import { CoreQuestionDelegate } from '@features/question/services/question-delegate';
import { CoreNetwork } from '@services/network';
import { CoreSites, CoreSitesReadingStrategy } from '@services/sites';
import { CoreSync, CoreSyncResult } from '@services/sync';
import { CorePromiseUtils } from '@singletons/promise-utils';
import { makeSingleton, Translate } from '@singletons';
import { CoreEvents } from '@singletons/events';
import { AddonModTabletTabletQuizAttemptDBRecord } from './database/tabletquiz';
import { type AddonModTabletTabletQuizPrefetchHandlerService } from './handlers/prefetch';
import { AddonModTabletTabletQuiz, AddonModTabletTabletQuizAttemptWSData, AddonModTabletTabletQuizTabletQuizWSData } from './tabletquiz';
import { AddonModTabletTabletQuizOffline, AddonModTabletTabletQuizQuestionsWithAnswers } from './tabletquiz-offline';
import {
    ADDON_MOD_TABLETQUIZ_AUTO_SYNCED,
    ADDON_MOD_TABLETQUIZ_COMPONENT,
    ADDON_MOD_TABLETQUIZ_COMPONENT_LEGACY,
    ADDON_MOD_TABLETQUIZ_MODNAME,
} from '../constants';
import { AddonModTabletTabletQuizHelper } from './tabletquiz-helper';

/**
 * Service to sync tabletquizzes.
 */
@Injectable({ providedIn: 'root' })
export class AddonModTabletTabletQuizSyncProvider extends CoreCourseActivitySyncBaseProvider<AddonModTabletTabletQuizSyncResult> {

    protected componentTranslatableString = 'tabletquiz';

    constructor() {
        super('AddonModTabletTabletQuizSyncProvider');
    }

    /**
     * Finish a sync process: remove offline data if needed, prefetch tabletquiz data, set sync time and return the result.
     *
     * @param siteId Site ID.
     * @param tabletquiz TabletQuiz.
     * @param courseId Course ID.
     * @param warnings List of warnings generated by the sync.
     * @param options Other options.
     * @returns Promise resolved on success.
     */
    protected async finishSync(
        siteId: string,
        tabletquiz: AddonModTabletTabletQuizTabletQuizWSData,
        courseId: number,
        warnings: string[],
        options?: FinishSyncOptions,
    ): Promise<AddonModTabletTabletQuizSyncResult> {
        options = options || {};

        // Invalidate the data for the tabletquiz and attempt.
        await CorePromiseUtils.ignoreErrors(
            AddonModTabletTabletQuiz.invalidateAllTabletQuizData(tabletquiz.id, courseId, options.attemptId, siteId),
        );

        if (options.removeAttempt && options.attemptId) {
            const promises: Promise<unknown>[] = [];

            promises.push(AddonModTabletTabletQuizOffline.removeAttemptAndAnswers(options.attemptId, siteId));

            if (options.onlineQuestions) {
                for (const slot in options.onlineQuestions) {
                    promises.push(CoreQuestionDelegate.deleteOfflineData(
                        options.onlineQuestions[slot],
                        ADDON_MOD_TABLETQUIZ_COMPONENT_LEGACY,
                        tabletquiz.coursemodule,
                        siteId,
                    ));
                }
            }

            await Promise.all(promises);
        }

        if (options.updated) {
            try {
                // Data has been sent. Update prefetched data.
                const module = await CoreCourse.getModuleBasicInfoByInstance(tabletquiz.id, ADDON_MOD_TABLETQUIZ_MODNAME, { siteId });

                await this.prefetchAfterUpdateTabletQuiz(module, tabletquiz, courseId, siteId);
            } catch {
                // Ignore errors.
            }
        }

        await CorePromiseUtils.ignoreErrors(this.setSyncTime(tabletquiz.id, siteId));

        // Check if online attempt was finished because of the sync.
        let attemptFinished = false;
        if (options.onlineAttempt && !AddonModTabletTabletQuiz.isAttemptCompleted(options.onlineAttempt.state)) {
            // Attempt wasn't finished at start. Check if it's finished now.
            const attempts = await AddonModTabletTabletQuiz.getUserAttempts(tabletquiz.id, { cmId: tabletquiz.coursemodule, siteId });

            const attempt = attempts.find(attempt => attempt.id == options?.onlineAttempt?.id);

            attemptFinished = attempt ? AddonModTabletTabletQuiz.isAttemptCompleted(attempt.state) : false;
        }

        return { warnings, attemptFinished, updated: !!options.updated || !!options.removeAttempt };
    }

    /**
     * Check if a tabletquiz has data to synchronize.
     *
     * @param tabletquizId TabletQuiz ID.
     * @param siteId Site ID. If not defined, current site.
     * @returns Promise resolved with boolean: whether it has data to sync.
     */
    async hasDataToSync(tabletquizId: number, siteId?: string): Promise<boolean> {
        try {
            const attempts = await AddonModTabletTabletQuizOffline.getTabletQuizAttempts(tabletquizId, siteId);

            return !!attempts.length;
        } catch {
            return false;
        }
    }

    /**
     * Convenience function to prefetch data after an update.
     *
     * @param module Module.
     * @param tabletquiz TabletQuiz.
     * @param courseId Course ID.
     * @param siteId Site ID. If not defined, current site.
     */
    protected async prefetchAfterUpdateTabletQuiz(
        module: CoreCourseModuleBasicInfo,
        tabletquiz: AddonModTabletTabletQuizTabletQuizWSData,
        courseId: number,
        siteId?: string,
    ): Promise<void> {
        let shouldDownload = false;

        // Get the module updates to check if the data was updated or not.
        const result = await CoreCourseModulePrefetchDelegate.getModuleUpdates(module, courseId, true, siteId);
        const prefetchHandler =
            CoreCourseModulePrefetchDelegate.getPrefetchHandlerFor<AddonModTabletTabletQuizPrefetchHandlerService>(module.modname);
        if (!prefetchHandler) {
            return;
        }

        if (result?.updates?.length) {
            const regex = /^.*files$/;

            // Only prefetch if files haven't changed.
            shouldDownload = !result.updates.find((entry) => entry.name.match(regex));

            if (shouldDownload) {
                await prefetchHandler.download(module, courseId, undefined, false, false);
            }
        }

        // Prefetch finished or not needed, set the right status.
        await prefetchHandler.setStatusAfterPrefetch(tabletquiz, {
            cmId: module.id,
            readingStrategy: shouldDownload ? CoreSitesReadingStrategy.PREFER_CACHE : undefined,
            siteId,
        });
    }

    /**
     * Try to synchronize all the tabletquizzes in a certain site or in all sites.
     *
     * @param siteId Site ID to sync. If not defined, sync all sites.
     * @param force Wether to force sync not depending on last execution.
     * @returns Promise resolved if sync is successful, rejected if sync fails.
     */
    syncAllTabletQuizzes(siteId?: string, force?: boolean): Promise<void> {
        return this.syncOnSites('all tabletquizzes', (siteId) => this.syncAllTabletQuizzesFunc(!!force, siteId), siteId);
    }

    /**
     * Sync all tabletquizzes on a site.
     *
     * @param force Wether to force sync not depending on last execution.
     * @param siteId Site ID to sync.
     */
    protected async syncAllTabletQuizzesFunc(force: boolean, siteId: string): Promise<void> {
        // Get all offline attempts.
        const attempts = await AddonModTabletTabletQuizOffline.getAllAttempts(siteId);

        const tabletquizIds: Record<number, boolean> = {}; // To prevent duplicates.

        // Sync all tabletquizzes that haven't been synced for a while and that aren't attempted right now.
        await Promise.all(attempts.map(async (attempt) => {
            if (tabletquizIds[attempt.tabletquizid]) {
                // TabletQuiz already treated.
                return;
            }
            tabletquizIds[attempt.tabletquizid] = true;

            if (CoreSync.isBlocked(ADDON_MOD_TABLETQUIZ_COMPONENT, attempt.tabletquizid, siteId)) {
                return;
            }

            // TabletQuiz not blocked, try to synchronize it.
            const tabletquiz = await AddonModTabletTabletQuiz.getTabletQuizById(attempt.courseid, attempt.tabletquizid, { siteId });

            const data = await (force ? this.syncTabletQuiz(tabletquiz, false, siteId) : this.syncTabletQuizIfNeeded(tabletquiz, false, siteId));

            if (data?.warnings?.length) {
                // Store the warnings to show them when the user opens the tabletquiz.
                await this.setSyncWarnings(tabletquiz.id, data.warnings, siteId);
            }

            if (data) {
                // Sync successful. Send event.
                CoreEvents.trigger(ADDON_MOD_TABLETQUIZ_AUTO_SYNCED, {
                    tabletquizId: tabletquiz.id,
                    attemptFinished: data.attemptFinished,
                    warnings: data.warnings,
                }, siteId);
            }
        }));
    }

    /**
     * Sync a tabletquiz only if a certain time has passed since the last time.
     *
     * @param tabletquiz TabletQuiz.
     * @param askPreflight Whether we should ask for preflight data if needed.
     * @param siteId Site ID. If not defined, current site.
     * @returns Promise resolved when the tabletquiz is synced or if it doesn't need to be synced.
     */
    async syncTabletQuizIfNeeded(
        tabletquiz: AddonModTabletTabletQuizTabletQuizWSData,
        askPreflight?: boolean,
        siteId?: string,
    ): Promise<AddonModTabletTabletQuizSyncResult | undefined> {
        const needed = await this.isSyncNeeded(tabletquiz.id, siteId);

        if (needed) {
            return this.syncTabletQuiz(tabletquiz, askPreflight, siteId);
        }
    }

    /**
     * Try to synchronize a tabletquiz.
     * The promise returned will be resolved with an array with warnings if the synchronization is successful.
     *
     * @param tabletquiz TabletQuiz.
     * @param askPreflight Whether we should ask for preflight data if needed.
     * @param siteId Site ID. If not defined, current site.
     * @returns Promise resolved in success.
     */
    syncTabletQuiz(tabletquiz: AddonModTabletTabletQuizTabletQuizWSData, askPreflight?: boolean, siteId?: string): Promise<AddonModTabletTabletQuizSyncResult> {
        siteId = siteId || CoreSites.getCurrentSiteId();

        const currentSyncPromise = this.getOngoingSync(tabletquiz.id, siteId);
        if (currentSyncPromise) {
            // There's already a sync ongoing for this tabletquiz, return the promise.
            return currentSyncPromise;
        }

        // Verify that tabletquiz isn't blocked.
        if (CoreSync.isBlocked(ADDON_MOD_TABLETQUIZ_COMPONENT, tabletquiz.id, siteId)) {
            this.logger.debug(`Cannot sync tabletquiz ${tabletquiz.id} because it is blocked.`);

            throw new CoreError(Translate.instant('core.errorsyncblocked', { $a: this.componentTranslate }));
        }

        return this.addOngoingSync(tabletquiz.id, this.performSyncTabletQuiz(tabletquiz, askPreflight, siteId), siteId);
    }

    /**
     * Perform the tabletquiz sync.
     *
     * @param tabletquiz TabletQuiz.
     * @param askPreflight Whether we should ask for preflight data if needed.
     * @param siteId Site ID. If not defined, current site.
     * @returns Promise resolved in success.
     */
    async performSyncTabletQuiz(tabletquiz: AddonModTabletTabletQuizTabletQuizWSData, askPreflight?: boolean, siteId?: string): Promise<AddonModTabletTabletQuizSyncResult> {
        siteId = siteId || CoreSites.getCurrentSiteId();

        const warnings: string[] = [];
        const courseId = tabletquiz.course;
        const modOptions = {
            cmId: tabletquiz.coursemodule,
            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,
            siteId,
        };

        this.logger.debug(`Try to sync tabletquiz ${tabletquiz.id} in site ${siteId}`);

        // Sync offline logs.
        await CorePromiseUtils.ignoreErrors(
            CoreCourseLogHelper.syncActivity(ADDON_MOD_TABLETQUIZ_COMPONENT_LEGACY, tabletquiz.id, siteId),
        );

        // Get all the offline attempts for the tabletquiz. It should always be 0 or 1 attempt
        const offlineAttempts = await AddonModTabletTabletQuizOffline.getTabletQuizAttempts(tabletquiz.id, siteId);
        const offlineAttempt = offlineAttempts.pop();

        if (!offlineAttempt) {
            // Nothing to sync, finish.
            return this.finishSync(siteId, tabletquiz, courseId, warnings);
        }

        if (!CoreNetwork.isOnline()) {
            // Cannot sync in offline.
            throw new CoreError(Translate.instant('core.cannotconnect'));
        }

        // Now get the list of online attempts to make sure this attempt exists and isn't finished.
        const onlineAttempts = await AddonModTabletTabletQuiz.getUserAttempts(tabletquiz.id, modOptions);

        const lastAttemptId = onlineAttempts.length ? onlineAttempts[onlineAttempts.length - 1].id : undefined;
        const onlineAttempt = onlineAttempts.find((attempt) => attempt.id == offlineAttempt.id);

        if (!onlineAttempt || AddonModTabletTabletQuiz.isAttemptCompleted(onlineAttempt.state)) {
            // Attempt not found or it's finished in online. Discard it.
            warnings.push(Translate.instant('addon.mod_tablettabletquiz.warningattemptfinished'));

            return this.finishSync(siteId, tabletquiz, courseId, warnings, {
                attemptId: offlineAttempt.id,
                offlineAttempt,
                onlineAttempt,
                removeAttempt: true,
            });
        }

        // Get the data stored in offline.
        const answersList = await AddonModTabletTabletQuizOffline.getAttemptAnswers(offlineAttempt.id, siteId);

        if (!answersList.length) {
            // No answers stored, finish.
            return this.finishSync(siteId, tabletquiz, courseId, warnings, {
                attemptId: lastAttemptId,
                offlineAttempt,
                onlineAttempt,
                removeAttempt: true,
            });
        }

        const offlineAnswers = CoreQuestion.convertAnswersArrayToObject(answersList);
        const offlineQuestions = AddonModTabletTabletQuizOffline.classifyAnswersInQuestions(offlineAnswers);

        // We're going to need preflightData, get it.
        const info = await AddonModTabletTabletQuiz.getTabletQuizAccessInformation(tabletquiz.id, modOptions);

        const preflightData = await AddonModTabletTabletQuizHelper.getPreflightDataToAttemptOffline(
            tabletquiz,
            info,
            onlineAttempt,
            askPreflight,
            'core.settings.synchronization',
            siteId,
        );

        // Now get the online questions data.
        const onlineQuestions = await AddonModTabletTabletQuiz.getAllQuestionsData(tabletquiz, onlineAttempt, preflightData, {
            pages: AddonModTabletTabletQuiz.getPagesFromLayoutAndQuestions(onlineAttempt.layout || '', offlineQuestions),
            readingStrategy: CoreSitesReadingStrategy.ONLY_NETWORK,
            siteId,
        });

        // Validate questions, discarding the offline answers that can't be synchronized.
        const discardedData = await this.validateQuestions(onlineAttempt.id, onlineQuestions, offlineQuestions, siteId);

        // Let questions prepare the data to send.
        await Promise.all(Object.keys(offlineQuestions).map(async (slotString) => {
            const slot = Number(slotString);
            const onlineQuestion = onlineQuestions[slot];

            await CoreQuestionDelegate.prepareSyncData(
                onlineQuestion,
                offlineQuestions[slot].answers,
                ADDON_MOD_TABLETQUIZ_COMPONENT_LEGACY,
                tabletquiz.coursemodule,
                siteId,
            );
        }));

        // Get the answers to send.
        const answers = AddonModTabletTabletQuizOffline.extractAnswersFromQuestions(offlineQuestions);
        const finish = !!offlineAttempt.finished && !discardedData;

        if (discardedData) {
            if (offlineAttempt.finished) {
                warnings.push(Translate.instant('addon.mod_tablettabletquiz.warningdatadiscardedfromfinished'));
            } else {
                warnings.push(Translate.instant('addon.mod_tablettabletquiz.warningdatadiscarded'));
            }
        }

        // Send the answers.
        await AddonModTabletTabletQuiz.processAttempt(tabletquiz, onlineAttempt, answers, preflightData, finish, false, false, siteId);

        if (!finish) {
            // Answers sent, now set the current page.
            await CorePromiseUtils.ignoreErrors(AddonModTabletTabletQuiz.logViewAttempt(
                onlineAttempt.id,
                offlineAttempt.currentpage,
                preflightData,
                false,
                siteId,
            ));
        }

        // Data sent. Finish the sync.
        return this.finishSync(siteId, tabletquiz, courseId, warnings, {
            attemptId: lastAttemptId,
            offlineAttempt,
            onlineAttempt,
            removeAttempt: true,
            updated: true,
            onlineQuestions,
        });
    }

    /**
     * Validate questions, discarding the offline answers that can't be synchronized.
     *
     * @param attemptId Attempt ID.
     * @param onlineQuestions Online questions
     * @param offlineQuestions Offline questions.
     * @param siteId Site ID. If not defined, current site.
     * @returns Promise resolved with boolean: true if some offline data was discarded, false otherwise.
     */
    async validateQuestions(
        attemptId: number,
        onlineQuestions: Record<number, CoreQuestionQuestionParsed>,
        offlineQuestions: AddonModTabletTabletQuizQuestionsWithAnswers,
        siteId?: string,
    ): Promise<boolean> {
        let discardedData = false;

        await Promise.all(Object.keys(offlineQuestions).map(async (slotString) => {
            const slot = Number(slotString);
            const offlineQuestion = offlineQuestions[slot];
            const onlineQuestion = onlineQuestions[slot];
            const offlineSequenceCheck = <string> offlineQuestion.answers[':sequencecheck'];

            if (onlineQuestion) {
                // We found the online data for the question, validate that the sequence check is ok.
                if (!CoreQuestionDelegate.validateSequenceCheck(onlineQuestion, offlineSequenceCheck)) {
                    // Sequence check is not valid, remove the offline data.
                    await AddonModTabletTabletQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);

                    discardedData = true;
                    delete offlineQuestions[slot];
                } else {
                    // Sequence check is valid. Use the online one to prevent synchronization errors.
                    offlineQuestion.answers[':sequencecheck'] = String(onlineQuestion.sequencecheck);
                }
            } else {
                // Online question not found, it can happen for 2 reasons:
                // 1- It's a sequential tabletquiz and the question is in a page already passed.
                // 2- TabletQuiz layout has changed (shouldn't happen since it's blocked if there are attempts).
                await AddonModTabletTabletQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId);

                discardedData = true;
                delete offlineQuestions[slot];
            }
        }));

        return discardedData;
    }

}

export const AddonModTabletTabletQuizSync = makeSingleton(AddonModTabletTabletQuizSyncProvider);

/**
 * Data returned by a tabletquiz sync.
 */
export type AddonModTabletTabletQuizSyncResult = CoreSyncResult & {
    attemptFinished: boolean; // Whether an attempt was finished in the site due to the sync.
};

/**
 * Options to pass to finish sync.
 */
type FinishSyncOptions = {
    attemptId?: number; // Last attempt ID.
    offlineAttempt?: AddonModTabletTabletQuizAttemptDBRecord; // Offline attempt synchronized, if any.
    onlineAttempt?: AddonModTabletTabletQuizAttemptWSData; // Online data for the offline attempt.
    removeAttempt?: boolean; // Whether the offline data should be removed.
    updated?: boolean; // Whether the offline data should be removed.
    onlineQuestions?: Record<number, CoreQuestionQuestionParsed>; // Online questions indexed by slot.
};

/**
 * Data passed to ADDON_MOD_TABLETQUIZ_AUTO_SYNCED event.
 */
export type AddonModTabletTabletQuizAutoSyncData = {
    tabletquizId: number;
    attemptFinished: boolean;
    warnings: string[];
};

declare module '@singletons/events' {

    /**
     * Augment CoreEventsData interface with events specific to this service.
     *
     * @see https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation
     */
    export interface CoreEventsData {
        [ADDON_MOD_TABLETQUIZ_AUTO_SYNCED]: AddonModTabletTabletQuizAutoSyncData;
    }

}
